Certainly! To make the Java application dynamic and capable of processing records from the ACHHEADER table with a specific STATUS_CODE and SETTLEMENT_DATE, we can introduce a timer to periodically check for records that need processing.

Here’s the updated code to implement this functionality. The application will run at a fixed interval, query the database, and process any records that match the specified criteria. It will fetch only one record at a time, write the data to a file, and then mark the record as processed or delete it based on your requirements.

ReturnFileGenerator_seq.java
This class remains largely unchanged but can be utilized to generate filenames.

ACHCR_Validation.java
This updated class will include a timer and implement the logic for fetching records based on the STATUS_CODE and SETTLEMENT_DATE.

java
Copy code
package com.Sept.nach.A;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {

    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final String STATUS_CODE = "10"; // Status code to filter
    private static final long TIMER_INTERVAL = 60000; // Check every 60 seconds

    private Timer timer;

    public static void main(String[] args) {
        ACHCR_Validation writer = new ACHCR_Validation();
        writer.startTimer();
    }

    private void startTimer() {
        timer = new Timer(true); // Timer runs as a daemon thread
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                processACHRecords();
            }
        }, 0, TIMER_INTERVAL);
    }

    private void processACHRecords() {
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
            // Fetch the record with STATUS_CODE 10 and current date
            String currentDate = new SimpleDateFormat("ddMMyyyy").format(new Date());
            String query = "SELECT * FROM ACHHEADER WHERE STATUS_CODE = ? AND SETTLEMENT_DATE = ? FETCH FIRST 1 ROWS ONLY";

            try (PreparedStatement stmt = conn.prepareStatement(query)) {
                stmt.setString(1, STATUS_CODE);
                stmt.setString(2, currentDate);

                ResultSet resultSet = stmt.executeQuery();
                if (resultSet.next()) {
                    // Process the retrieved record
                    String fileName = writeACHFile(resultSet, conn);

                    // Optionally, update the STATUS_CODE to mark as processed
                    updateStatusCode(conn, resultSet.getString("FILE_NAME"), "Processed");

                    System.out.println("Processed ACH record and written to file: " + fileName);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private String writeACHFile(ResultSet headerResult, Connection conn) throws SQLException {
        String outputFileName = null;
        try {
            // Generate the output file name dynamically
            outputFileName = ReturnFileGenerator_seq.generateReturnFile();

            // Write the ACH header to the file
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFileName))) {
                // Create header line from the ResultSet
                String headerLine = createHeaderLine(headerResult);
                writer.write(headerLine);
                writer.newLine();

                // Fetch and write data records
                String fileName = headerResult.getString("FILE_NAME");
                String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, " +
                        "BENEFICIARY_HOLDER_NAME, USER_NAME, AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, " +
                        "BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
                        "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
                        "WHERE FILE_NAME = ?";

                try (PreparedStatement dataStmt = conn.prepareStatement(dataQuery)) {
                    dataStmt.setString(1, fileName);
                    ResultSet dataResult = dataStmt.executeQuery();

                    while (dataResult.next()) {
                        String dataLine = createDataLine(dataResult);
                        writer.write(dataLine);
                        writer.newLine();
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return outputFileName; // Return the full file path
    }

    private String createHeaderLine(ResultSet rs) throws SQLException {
        StringBuilder header = new StringBuilder();
        header.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH transaction code
        header.append(String.format("%-7s", (rs.getString("CONTROL1") == null) ? "       " : rs.getString("CONTROL1"))); // Control
        header.append(String.format("%-87s", "")); // Filler
        header.append(String.format("%-7s", (rs.getString("CONTROL_CHARACTER") == null) ? "       " : rs.getString("CONTROL_CHARACTER"))); // Control
        header.append(String.format("%-9s", rs.getString("TOT_NO_OF_ITEMS"))); // Total Number of Items
        header.append(String.format("%-13s", rs.getString("TOT_AMOUNT"))); // Total Amount
        header.append(String.format("%-8s", rs.getString("SETTLEMENT_DATE"))); // Settlement Date
        header.append(String.format("%-8s", rs.getString("DESTINATION_BANK"))); // Destination Bank
        // Append other required fields...
        return header.toString();
    }

    private String createDataLine(ResultSet rs) throws SQLException {
        StringBuilder data = new StringBuilder();
        data.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH transaction code
        data.append(String.format("%-2s", rs.getString("DESTINATION_ACCOUNT_TYPE"))); // Destination Account Type
        // Append other required fields...
        return data.toString();
    }

    private void updateStatusCode(Connection conn, String fileName, String newStatus) {
        try {
            String updateQuery = "UPDATE ACHHEADER SET STATUS_CODE = ? WHERE FILE_NAME = ?";
            try (PreparedStatement updateStmt = conn.prepareStatement(updateQuery)) {
                updateStmt.setString(1, newStatus);
                updateStmt.setString(2, fileName);
                updateStmt.executeUpdate();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
Key Changes and Features
Timer Task: A timer is set to execute the processACHRecords method at regular intervals (60 seconds). You can adjust the TIMER_INTERVAL as needed.

Database Query: The application queries the ACHHEADER table for records with a STATUS_CODE of 10 and the current date in the format DDMMYYYY.

Single Record Processing: The application processes only one record at a time using FETCH FIRST 1 ROWS ONLY.

File Writing: The writeACHFile method writes the header and associated data records from ACHFILE to a dynamically generated file.

Status Code Update: After processing, the STATUS_CODE is updated to mark the record as processed. This can be customized based on your requirements (e.g., delete the record, update a different column, etc.).

Error Handling: Basic error handling is included to manage exceptions that might occur during database access or file writing.

Note
Make sure to test this in a safe environment, especially if you are interacting with a production database.
You might need to adjust the database connection parameters and SQL queries to match your actual database schema and requirements.


--------------------------------------------------------------------xxxxxxx


debug this code package com.Sept.nach.C;



import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {
    private String pattern = "ddMMyyyy";
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final long INTERVAL = 2 * 60 * 1000; // 2 minutes

    // Using dynamic file name generated from ReturnFileGenerator_seq
    private String outputFileName;

    public static void main(String[] args) {
        ACHCR_Validation writer = new ACHCR_Validation();
        writer.writeACHFile();
    }
    
    public void scheduleACHProcessing() {
        Timer timer = new Timer(true);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                processACHFiles();
            }
        }, 0, INTERVAL);

        System.out.println("ACH file processing scheduled to run every 2 minutes.");
    }

    private void processACHFiles() {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows with FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (Processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Process the file and generate the return file
                ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                String success = returnFileGen.generateReturnFile(fileName);

                // Update the table based on the result of the return file generation
                if (success !=null) {
                    updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    
    private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, status);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }
    
    
    public ACHCR_Validation() {
        // Generate the output file name dynamically
        try {
            this.outputFileName = generateDynamicFileName();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

//    public void writeACHFile() {
//        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
//            if (validateRowCount(conn)) {
//                // Proceed to write the file using the dynamically generated file name
//                try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName));
//                     Statement stmt = conn.createStatement()) {
//
//                    // Fetch header data for writing to the file
//                    String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
//                            "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
//                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
//
//                    ResultSet headerResult = stmt.executeQuery(headerQuery);
//                    if (headerResult.next()) {
//                        String headerLine = createHeaderLine(headerResult);
//                        writer.write(headerLine);
//                        writer.newLine();
//                    }
//
//                    // Fetch data records and write them to the file
//                    String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
//                            "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
//                            "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
//                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
//
//                    ResultSet dataResult = stmt.executeQuery(dataQuery);
//                    while (dataResult.next()) {
//                        String dataLine = createDataLine(dataResult);
//                        writer.write(dataLine);
//                        writer.newLine();
//                    }
//
//                    System.out.println("ACH file written successfully to " + this.outputFileName);
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//            } else {
//                System.out.println("The file contents are invalid. The number of rows does not match.");
//            }
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }
    
    public void writeACHFile(int fileStatus) throws Exception {
        Connection conn = null;
        PreparedStatement headerStmt = null;
        PreparedStatement dataStmt = null;
        ResultSet headerResult = null;
        ResultSet dataResult = null;
        
        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Dynamically generate the query to get FILE_NAME and SETTLEMENT_DATE from the database
            String fetchACHHeaderSQL = "SELECT FILE_NAME, SETTLEMENT_DATE FROM ACHHEADER WHERE FILE_STATUS = ?";

            try (PreparedStatement fetchHeaderStmt = conn.prepareStatement(fetchACHHeaderSQL)) {
                fetchHeaderStmt.setInt(1, fileStatus);  // Set the dynamic FILE_STATUS value
                ResultSet headerSet = fetchHeaderStmt.executeQuery();

                if (headerSet.next()) {
                    String fileName = headerSet.getString("FILE_NAME");
                    String settlementDate = headerSet.getString("SETTLEMENT_DATE");

                    // Now use the dynamically fetched fileName and settlementDate in subsequent queries

                    if (validateRowCount(conn)) {
                        // Proceed to write the file using the dynamically generated file name
                        try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName))) {

                            // Dynamically generate header query
                            String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
                                    "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
                                    "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                            headerStmt = conn.prepareStatement(headerQuery);
                            headerStmt.setString(1, fileName);
                            headerStmt.setString(2, settlementDate);
                            headerResult = headerStmt.executeQuery();

                            if (headerResult.next()) {
                                String headerLine = createHeaderLine(headerResult);
                                writer.write(headerLine);
                                writer.newLine();
                            }

                            // Dynamically generate data query
                            String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
                                    "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
                                    "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
                                    "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                            dataStmt = conn.prepareStatement(dataQuery);
                            dataStmt.setString(1, fileName);
                            dataStmt.setString(2, settlementDate);
                            dataResult = dataStmt.executeQuery();

                            // Write each data row to the file
                            while (dataResult.next()) {
                                String dataLine = createDataLine(dataResult);
                                writer.write(dataLine);
                                writer.newLine();
                            }

                            System.out.println("ACH file written successfully to " + this.outputFileName);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    } else {
                        System.out.println("The file contents are invalid. The number of rows does not match.");
                    }
                } else {
                    System.out.println("No matching records found for the given file status: " + fileStatus);
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (headerResult != null) headerResult.close();
                if (dataResult != null) dataResult.close();
                if (headerStmt != null) headerStmt.close();
                if (dataStmt != null) dataStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    

    private boolean validateRowCount(Connection conn) {
        try {
            String headerQuery = "SELECT TOT_NO_OF_ITEMS FROM ACHHEADER WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
            PreparedStatement headerStatement = conn.prepareStatement(headerQuery);
            ResultSet headerResult = headerStatement.executeQuery();

            if (headerResult.next()) {
                int totalNoOfItems = headerResult.getInt("TOT_NO_OF_ITEMS");

                String dataQuery = "SELECT COUNT(*) AS ROW_COUNT FROM ACHFILE WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
                PreparedStatement dataStatement = conn.prepareStatement(dataQuery);
                ResultSet dataResult = dataStatement.executeQuery();

                if (dataResult.next()) {
                    int rowCount = dataResult.getInt("ROW_COUNT");
                    return rowCount == totalNoOfItems;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    private String createHeaderLine(ResultSet rs) throws Exception {
        StringBuilder header = new StringBuilder();
        header.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH transaction code
        header.append(String.format("%-7s", (rs.getString("CONTROL1") == null) ? "       " : "")); // Control
        header.append(String.format("%-87s", "")); // Filler
        header.append(String.format("%-7s", (rs.getString("CONTROL_CHARACTER") == null) ? "       " : "")); // Control
        header.append(String.format("%-9s", rs.getString("TOT_NO_OF_ITEMS"))); // Total Number of Items
        header.append(String.format("%-13s", rs.getString("TOT_AMOUNT"))); // Total Amount
        header.append(String.format("%-8s", rs.getString("SETTLEMENT_DATE"))); // Settlement Date
        header.append(String.format("%-8s", (rs.getString("INW_GEN_DATE") == null) ? "        " : "        ")); // Inward Generation Date
        header.append(String.format("%-19s", "")); // Filler
        header.append(String.format("%-11s", rs.getString("DESTINATION_BANK"))); // Destination Bank IFSC
        header.append(String.format("%-2s", rs.getString("SETTLEMENT_CYCLE"))); // Settlement Cycle
        header.append(String.format("%-133s", "                                                                                                                                     .")); // Filler with dot
        return header.toString();
    }

    private String createDataLine(ResultSet rs) throws Exception {
        String dateInString = new SimpleDateFormat(pattern).format(new Date());

        StringBuilder data = new StringBuilder();
        data.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH Transaction Code
        data.append(String.format("%-9s", "")); // Control
        data.append(String.format("%-2s", rs.getString("DESTINATION_ACCOUNT_TYPE"))); // Destination Account Type
        data.append(String.format("%-3s", (rs.getString("LEDGER_FOLIO_NUMBER") == null) ? "   " : "   ")); // Ledger Folio Number
        data.append(String.format("%-15s", "")); // Spaces User defined return reason
        data.append(String.format("%-40s", rs.getString("BENEFICIARY_HOLDER_NAME"))); // Beneficiary Account Holder's Name
        data.append(String.format("%-8s", "")); // Control spaces
        data.append(String.format("%-8s", "")); // User defined return reason spaces
        data.append(String.format("%-20s", rs.getString("USER_NAME"))); // User Name / Narration
        data.append(String.format("%-13s", "")); // Control
        data.append(String.format("%-13s", rs.getString("AMOUNT"))); // Amount
        data.append(String.format("%-10s", rs.getString("ACH_SEQ_NO"))); // ACH Item Seq No.
        data.append(String.format("%-10s", rs.getString("CHECKSUM"))); // Checksum
        data.append(String.format("%-7s", "")); // Reserved (Filler)
        data.append(String.format("%-11s", rs.getString("DEST_BANK"))); // Destination Bank IFSC
        data.append(String.format("%-35s", rs.getString("BENEFICIARY_BANK_ACCNO"))); // Beneficiary's Bank Account number
        data.append(String.format("%-11s", rs.getString("SPONSOR_BANK"))); // Sponsor Bank IFSC
        data.append(String.format("%-18s", rs.getString("USER_NUMBER"))); // User Number
        data.append(String.format("%-30s", rs.getString("TRANSACTION_REFERENCE"))); // Transaction Reference
        data.append(String.format("%-3s", rs.getString("PRODUCT_TYPE"))); // Product Type
        data.append(String.format("%-15s", rs.getString("BENEFICIARY_AADHAAR_NO"))); // Beneficiary Aadhaar Number
        data.append(String.format("%-20s", rs.getString("UMRN"))); // UMRN
        data.append(String.format("%-1s", rs.getString("FLAG"))); // Flag for success / return
        data.append(String.format("%-2s", rs.getString("REASON_CODE"))); // Reason Code
        data.append(String.format("%-8s", dateInString)); // Processed date
        return data.toString();
    }

    // Method to generate the file name dynamically from ReturnFileGenerator_seq
    private String generateDynamicFileName() throws IOException {
        return ReturnFileGenerator_seq.generateReturnFile();
    }
}
ChatGPT said:
ChatGPT
Here are some potential issues and fixes for your code:

1. Database URL and Credentials
The DB_URL value you provided uses the default Oracle connection string (jdbc:oracle:thin:@localhost:1521:orcl), which may not be correctly configured.
Ensure that Oracle is running, and the connection parameters are valid.
Also, using SYS as SYSDBA should be avoided for general operations since it’s a highly privileged account. Use a regular user account.
Solution:
Use a regular user instead of SYS as SYSDBA and correct the credentials:

java
Copy code
private static final String USER = "your_user";  // Replace with correct DB user
private static final String PASS = "your_password";  // Replace with correct password
2. Oracle Driver
Ensure that the Oracle JDBC driver (ojdbc8.jar) is included in the classpath. You can download it from Oracle's website and add it to your project dependencies.

3. File Writing Logic
Your writeACHFile method is commented out and should be active if you want to write the ACH file. Also, the BufferedWriter logic should check for potential issues in file generation.
4. Hardcoded Values
In methods like validateRowCount and the commented-out writeACHFile, values like the file name and settlement date are hardcoded, which reduces flexibility.

Solution:
Fetch those values dynamically (which you are already doing elsewhere) instead of hardcoding:

java
Copy code
String fileName = headerSet.getString("FILE_NAME");
String settlementDate = headerSet.getString("SETTLEMENT_DATE");
5. Exception Handling
You should improve exception handling to provide more useful debugging information. Instead of e.printStackTrace();, consider logging the error or rethrowing a custom exception for better clarity.

Solution:
You could add logging or use a specific error-handling mechanism.

6. SQL Resource Management
Even though you are closing resources in finally blocks, it’s recommended to use the try-with-resources statement for cleaner and more efficient code.

Solution:
Use try-with-resources:

java
Copy code
try (PreparedStatement stmt = conn.prepareStatement(query);
     ResultSet rs = stmt.executeQuery()) {
    // process result set
}
7. Class ReturnFileGenerator_seq
It seems like you are trying to generate file names using ReturnFileGenerator_seq. Ensure this class exists and works properly. The method generateReturnFile() should return valid file names.

Solution:
Make sure ReturnFileGenerator_seq has the following method:

java
Copy code
public class ReturnFileGenerator_seq {
    public static String generateReturnFile() {
        // Logic to generate the return file name
        return "your_generated_file_name";
    }
}
8. Main Method Logic
You are calling writeACHFile in the main method without arguments. If you intend to use a specific file status, the method should take that argument, and you should call it appropriately.

Solution:
Modify your main method:

java
Copy code
public static void main(String[] args) {
    ACHCR_Validation writer = new ACHCR_Validation();
    try {
        writer.writeACHFile(10);  // Pass appropriate file status
    } catch (Exception e) {
        e.printStackTrace();
    }
}
9. SQL Query Efficiency
Currently, your SQL queries are fetching all fields using SELECT *. For performance reasons, it’s generally better to explicitly mention only the required fields.

Solution:
Modify queries:

java
Copy code
String selectSQL = "SELECT ID, FILE_NAME FROM ACHHEADER WHERE FILE_STATUS = 10";
Final Code Updates:
Here’s how some of your updated methods should look:

java
Copy code
public static void main(String[] args) {
    ACHCR_Validation writer = new ACHCR_Validation();
    writer.scheduleACHProcessing();
}

private void processACHFiles() {
    String selectSQL = "SELECT ID, FILE_NAME FROM ACHHEADER WHERE FILE_STATUS = 10";
    try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);
         PreparedStatement selectStmt = conn.prepareStatement(selectSQL);
         ResultSet rs = selectStmt.executeQuery()) {

        while (rs.next()) {
            int id = rs.getInt("ID");
            String fileName = rs.getString("FILE_NAME");

            // Process file
            processACHFileRecord(conn, id, fileName);
        }

    } catch (SQLException e) {
        e.printStackTrace();
    }
}

private void processACHFileRecord(Connection conn, int id, String fileName) throws SQLException {
    String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
    try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
        updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
        updateStmt.setInt(2, id);
        updateStmt.executeUpdate();

        // Further processing logic...
    }
}
Try running these updates and check if the issues persist.






You said:
kindly give suggection is my code running on timmer babsing is it writing file and generating return file  and at the end give code change package com.Sept.nach.C; 



import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {
    private String pattern = "ddMMyyyy";
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final long INTERVAL = 2 * 60 * 1000; // 2 minutes

    // Using dynamic file name generated from ReturnFileGenerator_seq
    private String outputFileName;

    public static void main(String[] args) {
        ACHCR_Validation writer = new ACHCR_Validation();
        writer.writeACHFile();
    }
    
    public void scheduleACHProcessing() {
        Timer timer = new Timer(true);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                processACHFiles();
            }
        }, 0, INTERVAL);

        System.out.println("ACH file processing scheduled to run every 2 minutes.");
    }

    private void processACHFiles() {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows with FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (Processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Process the file and generate the return file
                ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                String success = returnFileGen.generateReturnFile(fileName);

                // Update the table based on the result of the return file generation
                if (success !=null) {
                    updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    
    private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, status);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }
    
    
    public ACHCR_Validation() {
        // Generate the output file name dynamically
        try {
            this.outputFileName = generateDynamicFileName();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

//    public void writeACHFile() {
//        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
//            if (validateRowCount(conn)) {
//                // Proceed to write the file using the dynamically generated file name
//                try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName));
//                     Statement stmt = conn.createStatement()) {
//
//                    // Fetch header data for writing to the file
//                    String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
//                            "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
//                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
//
//                    ResultSet headerResult = stmt.executeQuery(headerQuery);
//                    if (headerResult.next()) {
//                        String headerLine = createHeaderLine(headerResult);
//                        writer.write(headerLine);
//                        writer.newLine();
//                    }
//
//                    // Fetch data records and write them to the file
//                    String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
//                            "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
//                            "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
//                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
//
//                    ResultSet dataResult = stmt.executeQuery(dataQuery);
//                    while (dataResult.next()) {
//                        String dataLine = createDataLine(dataResult);
//                        writer.write(dataLine);
//                        writer.newLine();
//                    }
//
//                    System.out.println("ACH file written successfully to " + this.outputFileName);
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//            } else {
//                System.out.println("The file contents are invalid. The number of rows does not match.");
//            }
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }
    
    public void writeACHFile(int fileStatus) throws Exception {
        Connection conn = null;
        PreparedStatement headerStmt = null;
        PreparedStatement dataStmt = null;
        ResultSet headerResult = null;
        ResultSet dataResult = null;
        
        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Dynamically generate the query to get FILE_NAME and SETTLEMENT_DATE from the database
            String fetchACHHeaderSQL = "SELECT FILE_NAME, SETTLEMENT_DATE FROM ACHHEADER WHERE FILE_STATUS = ?";

            try (PreparedStatement fetchHeaderStmt = conn.prepareStatement(fetchACHHeaderSQL)) {
                fetchHeaderStmt.setInt(1, fileStatus);  // Set the dynamic FILE_STATUS value
                ResultSet headerSet = fetchHeaderStmt.executeQuery();

                if (headerSet.next()) {
                    String fileName = headerSet.getString("FILE_NAME");
                    String settlementDate = headerSet.getString("SETTLEMENT_DATE");

                    // Now use the dynamically fetched fileName and settlementDate in subsequent queries

                    if (validateRowCount(conn)) {
                        // Proceed to write the file using the dynamically generated file name
                        try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName))) {

                            // Dynamically generate header query
                            String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
                                    "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
                                    "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                            headerStmt = conn.prepareStatement(headerQuery);
                            headerStmt.setString(1, fileName);
                            headerStmt.setString(2, settlementDate);
                            headerResult = headerStmt.executeQuery();

                            if (headerResult.next()) {
                                String headerLine = createHeaderLine(headerResult);
                                writer.write(headerLine);
                                writer.newLine();
                            }

                            // Dynamically generate data query
                            String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
                                    "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
                                    "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
                                    "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                            dataStmt = conn.prepareStatement(dataQuery);
                            dataStmt.setString(1, fileName);
                            dataStmt.setString(2, settlementDate);
                            dataResult = dataStmt.executeQuery();

                            // Write each data row to the file
                            while (dataResult.next()) {
                                String dataLine = createDataLine(dataResult);
                                writer.write(dataLine);
                                writer.newLine();
                            }

                            System.out.println("ACH file written successfully to " + this.outputFileName);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    } else {
                        System.out.println("The file contents are invalid. The number of rows does not match.");
                    }
                } else {
                    System.out.println("No matching records found for the given file status: " + fileStatus);
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (headerResult != null) headerResult.close();
                if (dataResult != null) dataResult.close();
                if (headerStmt != null) headerStmt.close();
                if (dataStmt != null) dataStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    

    private boolean validateRowCount(Connection conn) {
        try {
            String headerQuery = "SELECT TOT_NO_OF_ITEMS FROM ACHHEADER WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
            PreparedStatement headerStatement = conn.prepareStatement(headerQuery);
            ResultSet headerResult = headerStatement.executeQuery();

            if (headerResult.next()) {
                int totalNoOfItems = headerResult.getInt("TOT_NO_OF_ITEMS");

                String dataQuery = "SELECT COUNT(*) AS ROW_COUNT FROM ACHFILE WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
                PreparedStatement dataStatement = conn.prepareStatement(dataQuery);
                ResultSet dataResult = dataStatement.executeQuery();

                if (dataResult.next()) {
                    int rowCount = dataResult.getInt("ROW_COUNT");
                    return rowCount == totalNoOfItems;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    private String createHeaderLine(ResultSet rs) throws Exception {
        StringBuilder header = new StringBuilder();
        header.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH transaction code
        header.append(String.format("%-7s", (rs.getString("CONTROL1") == null) ? "       " : "")); // Control
        header.append(String.format("%-87s", "")); // Filler
        header.append(String.format("%-7s", (rs.getString("CONTROL_CHARACTER") == null) ? "       " : "")); // Control
        header.append(String.format("%-9s", rs.getString("TOT_NO_OF_ITEMS"))); // Total Number of Items
        header.append(String.format("%-13s", rs.getString("TOT_AMOUNT"))); // Total Amount
        header.append(String.format("%-8s", rs.getString("SETTLEMENT_DATE"))); // Settlement Date
        header.append(String.format("%-8s", (rs.getString("INW_GEN_DATE") == null) ? "        " : "        ")); // Inward Generation Date
        header.append(String.format("%-19s", "")); // Filler
        header.append(String.format("%-11s", rs.getString("DESTINATION_BANK"))); // Destination Bank IFSC
        header.append(String.format("%-2s", rs.getString("SETTLEMENT_CYCLE"))); // Settlement Cycle
        header.append(String.format("%-133s", "                                                                                                                                     .")); // Filler with dot
        return header.toString();
    }

    private String createDataLine(ResultSet rs) throws Exception {
        String dateInString = new SimpleDateFormat(pattern).format(new Date());

        StringBuilder data = new StringBuilder();
        data.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH Transaction Code
        data.append(String.format("%-9s", "")); // Control
        data.append(String.format("%-2s", rs.getString("DESTINATION_ACCOUNT_TYPE"))); // Destination Account Type
        data.append(String.format("%-3s", (rs.getString("LEDGER_FOLIO_NUMBER") == null) ? "   " : "   ")); // Ledger Folio Number
        data.append(String.format("%-15s", "")); // Spaces User defined return reason
        data.append(String.format("%-40s", rs.getString("BENEFICIARY_HOLDER_NAME"))); // Beneficiary Account Holder's Name
        data.append(String.format("%-8s", "")); // Control spaces
        data.append(String.format("%-8s", "")); // User defined return reason spaces
        data.append(String.format("%-20s", rs.getString("USER_NAME"))); // User Name / Narration
        data.append(String.format("%-13s", "")); // Control
        data.append(String.format("%-13s", rs.getString("AMOUNT"))); // Amount
        data.append(String.format("%-10s", rs.getString("ACH_SEQ_NO"))); // ACH Item Seq No.
        data.append(String.format("%-10s", rs.getString("CHECKSUM"))); // Checksum
        data.append(String.format("%-7s", "")); // Reserved (Filler)
        data.append(String.format("%-11s", rs.getString("DEST_BANK"))); // Destination Bank IFSC
        data.append(String.format("%-35s", rs.getString("BENEFICIARY_BANK_ACCNO"))); // Beneficiary's Bank Account number
        data.append(String.format("%-11s", rs.getString("SPONSOR_BANK"))); // Sponsor Bank IFSC
        data.append(String.format("%-18s", rs.getString("USER_NUMBER"))); // User Number
        data.append(String.format("%-30s", rs.getString("TRANSACTION_REFERENCE"))); // Transaction Reference
        data.append(String.format("%-3s", rs.getString("PRODUCT_TYPE"))); // Product Type
        data.append(String.format("%-15s", rs.getString("BENEFICIARY_AADHAAR_NO"))); // Beneficiary Aadhaar Number
        data.append(String.format("%-20s", rs.getString("UMRN"))); // UMRN
        data.append(String.format("%-1s", rs.getString("FLAG"))); // Flag for success / return
        data.append(String.format("%-2s", rs.getString("REASON_CODE"))); // Reason Code
        data.append(String.format("%-8s", dateInString)); // Processed date
        return data.toString();
    }

    // Method to generate the file name dynamically from ReturnFileGenerator_seq
    private String generateDynamicFileName() throws IOException {
        return ReturnFileGenerator_seq.generateReturnFile();
    }
}
ChatGPT said:
ChatGPT
To evaluate your code and ensure it's functioning as expected with the timer for file writing and return file generation, here’s a breakdown:

Key Components:
Timer for Scheduling:

The timer is correctly scheduled in scheduleACHProcessing() to trigger the processing every 2 minutes (120,000 milliseconds).
It invokes processACHFiles() which fetches records from the database with FILE_STATUS = 10, updates their status to 11 (processing), generates a return file, and updates the status again based on success or failure.
File Writing:

The method writeACHFile(int fileStatus) dynamically fetches the FILE_NAME and SETTLEMENT_DATE from the database and writes the corresponding header and data rows into a file.
The file generation logic uses BufferedWriter to write to a dynamically generated file name (outputFileName).
Return File Generation:

The method generateReturnFile() in the class ReturnFileGenerator_seq is responsible for generating the return file. This is invoked inside processACHFiles() for each file.
If successful, the status is updated to 12 (success), and 13 for failure.
Suggestions for Code Improvement and Changes:
Timer Initialization: Ensure the scheduleACHProcessing() method is called within main() to initialize the timer for file processing.

java
Copy code
public static void main(String[] args) {
    ACHCR_Validation writer = new ACHCR_Validation();
    writer.scheduleACHProcessing();
}
Log Messages:

Enhance log messages within each method to track execution, making debugging easier. For example, log when a file is being processed or skipped.
Add logging for important operations, such as fetching the database records, updating file statuses, and file writing completion.
Error Handling and Transaction Management:

Consider wrapping database operations inside a transaction block (begin/commit/rollback) to handle failures more gracefully.
In case of failure in return file generation, perform a rollback to ensure consistency in the database.
Concurrency:

If you expect multiple files to be processed concurrently, consider using a ScheduledExecutorService instead of Timer, as it handles exceptions better and allows concurrent execution of tasks.
Resource Cleanup:

While you close database connections and result sets in finally blocks, ensure that resources are properly closed even when exceptions occur in nested try blocks.
You can use Java 7+ try-with-resources for cleaner resource management.
Code Refactor for File Writing:

Refactor writeACHFile(int fileStatus) to avoid deeply nested logic, improving readability. Separate query execution from file writing logic.
Handle file I/O exceptions more gracefully.
Revised Main Method and Timer Setup:
java
Copy code
public static void main(String[] args) {
    ACHCR_Validation writer = new ACHCR_Validation();
    writer.scheduleACHProcessing();
}
Refactor for Clean Resource Handling (Example):
Instead of:

java
Copy code
PreparedStatement headerStmt = null;
PreparedStatement dataStmt = null;
ResultSet headerResult = null;
ResultSet dataResult = null;
try {
    headerStmt = conn.prepareStatement(headerQuery);
    headerResult = headerStmt.executeQuery();
    // similar for dataStmt and dataResult...
} finally {
    if (headerResult != null) headerResult.close();
    if (headerStmt != null) headerStmt.close();
}
You can simplify:

java
Copy code
try (PreparedStatement headerStmt = conn.prepareStatement(headerQuery);
     ResultSet headerResult = headerStmt.executeQuery()) {
    // logic to process result set
}
Summary:
File Writing: Your code is writing the file correctly.
Return File Generation: The return file generation logic appears correct but ensure ReturnFileGenerator_seq.generateReturnFile() returns meaningful success/failure responses.
Timer-Based Execution: The timer is scheduled properly, running every 2 minutes.





You said:
package com.Sept.nach.C;



import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {
    private String pattern = "ddMMyyyy";
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final long INTERVAL = 2 * 60 * 1000; // 2 minutes

    // Using dynamic file name generated from ReturnFileGenerator_seq
    private String outputFileName;

    public static void main(String[] args) {
        ACHCR_Validation writer = new ACHCR_Validation();
        writer.writeACHFile();
    }
    
    public void scheduleACHProcessing() {
        Timer timer = new Timer(true);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                processACHFiles();
            }
        }, 0, INTERVAL);

        System.out.println("ACH file processing scheduled to run every 2 minutes.");
    }

    private void processACHFiles() {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows with FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (Processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Process the file and generate the return file
                ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                String success = returnFileGen.generateReturnFile(fileName);

                // Update the table based on the result of the return file generation
                if (success !=null) {
                    updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    
    private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, status);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }
    
    
    public ACHCR_Validation() {
        // Generate the output file name dynamically
        try {
            this.outputFileName = generateDynamicFileName();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

//    public void writeACHFile() {
//        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
//            if (validateRowCount(conn)) {
//                // Proceed to write the file using the dynamically generated file name
//                try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName));
//                     Statement stmt = conn.createStatement()) {
//
//                    // Fetch header data for writing to the file
//                    String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
//                            "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
//                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
//
//                    ResultSet headerResult = stmt.executeQuery(headerQuery);
//                    if (headerResult.next()) {
//                        String headerLine = createHeaderLine(headerResult);
//                        writer.write(headerLine);
//                        writer.newLine();
//                    }
//
//                    // Fetch data records and write them to the file
//                    String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
//                            "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
//                            "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
//                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
//
//                    ResultSet dataResult = stmt.executeQuery(dataQuery);
//                    while (dataResult.next()) {
//                        String dataLine = createDataLine(dataResult);
//                        writer.write(dataLine);
//                        writer.newLine();
//                    }
//
//                    System.out.println("ACH file written successfully to " + this.outputFileName);
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//            } else {
//                System.out.println("The file contents are invalid. The number of rows does not match.");
//            }
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }
    
    public void writeACHFile(int fileStatus) throws Exception {
        Connection conn = null;
        PreparedStatement headerStmt = null;
        PreparedStatement dataStmt = null;
        ResultSet headerResult = null;
        ResultSet dataResult = null;
        
        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Dynamically generate the query to get FILE_NAME and SETTLEMENT_DATE from the database
            String fetchACHHeaderSQL = "SELECT FILE_NAME, SETTLEMENT_DATE FROM ACHHEADER WHERE FILE_STATUS = ?";

            try (PreparedStatement fetchHeaderStmt = conn.prepareStatement(fetchACHHeaderSQL)) {
                fetchHeaderStmt.setInt(1, fileStatus);  // Set the dynamic FILE_STATUS value
                ResultSet headerSet = fetchHeaderStmt.executeQuery();

                if (headerSet.next()) {
                    String fileName = headerSet.getString("FILE_NAME");
                    String settlementDate = headerSet.getString("SETTLEMENT_DATE");

                    // Now use the dynamically fetched fileName and settlementDate in subsequent queries

                    if (validateRowCount(conn)) {
                        // Proceed to write the file using the dynamically generated file name
                        try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName))) {

                            // Dynamically generate header query
                            String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
                                    "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
                                    "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                            headerStmt = conn.prepareStatement(headerQuery);
                            headerStmt.setString(1, fileName);
                            headerStmt.setString(2, settlementDate);
                            headerResult = headerStmt.executeQuery();

                            if (headerResult.next()) {
                                String headerLine = createHeaderLine(headerResult);
                                writer.write(headerLine);
                                writer.newLine();
                            }

                            // Dynamically generate data query
                            String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
                                    "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
                                    "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
                                    "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                            dataStmt = conn.prepareStatement(dataQuery);
                            dataStmt.setString(1, fileName);
                            dataStmt.setString(2, settlementDate);
                            dataResult = dataStmt.executeQuery();

                            // Write each data row to the file
                            while (dataResult.next()) {
                                String dataLine = createDataLine(dataResult);
                                writer.write(dataLine);
                                writer.newLine();
                            }

                            System.out.println("ACH file written successfully to " + this.outputFileName);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    } else {
                        System.out.println("The file contents are invalid. The number of rows does not match.");
                    }
                } else {
                    System.out.println("No matching records found for the given file status: " + fileStatus);
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (headerResult != null) headerResult.close();
                if (dataResult != null) dataResult.close();
                if (headerStmt != null) headerStmt.close();
                if (dataStmt != null) dataStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    

    private boolean validateRowCount(Connection conn) {
        try {
            String headerQuery = "SELECT TOT_NO_OF_ITEMS FROM ACHHEADER WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
            PreparedStatement headerStatement = conn.prepareStatement(headerQuery);
            ResultSet headerResult = headerStatement.executeQuery();

            if (headerResult.next()) {
                int totalNoOfItems = headerResult.getInt("TOT_NO_OF_ITEMS");

                String dataQuery = "SELECT COUNT(*) AS ROW_COUNT FROM ACHFILE WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
                PreparedStatement dataStatement = conn.prepareStatement(dataQuery);
                ResultSet dataResult = dataStatement.executeQuery();

                if (dataResult.next()) {
                    int rowCount = dataResult.getInt("ROW_COUNT");
                    return rowCount == totalNoOfItems;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    private String createHeaderLine(ResultSet rs) throws Exception {
        StringBuilder header = new StringBuilder();
        header.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH transaction code
        header.append(String.format("%-7s", (rs.getString("CONTROL1") == null) ? "       " : "")); // Control
        header.append(String.format("%-87s", "")); // Filler
        header.append(String.format("%-7s", (rs.getString("CONTROL_CHARACTER") == null) ? "       " : "")); // Control
        header.append(String.format("%-9s", rs.getString("TOT_NO_OF_ITEMS"))); // Total Number of Items
        header.append(String.format("%-13s", rs.getString("TOT_AMOUNT"))); // Total Amount
        header.append(String.format("%-8s", rs.getString("SETTLEMENT_DATE"))); // Settlement Date
        header.append(String.format("%-8s", (rs.getString("INW_GEN_DATE") == null) ? "        " : "        ")); // Inward Generation Date
        header.append(String.format("%-19s", "")); // Filler
        header.append(String.format("%-11s", rs.getString("DESTINATION_BANK"))); // Destination Bank IFSC
        header.append(String.format("%-2s", rs.getString("SETTLEMENT_CYCLE"))); // Settlement Cycle
        header.append(String.format("%-133s", "                                                                                                                                     .")); // Filler with dot
        return header.toString();
    }

    private String createDataLine(ResultSet rs) throws Exception {
        String dateInString = new SimpleDateFormat(pattern).format(new Date());

        StringBuilder data = new StringBuilder();
        data.append(String.format("%-2s", rs.getString("ACH_TRANSACTION_CODE"))); // ACH Transaction Code
        data.append(String.format("%-9s", "")); // Control
        data.append(String.format("%-2s", rs.getString("DESTINATION_ACCOUNT_TYPE"))); // Destination Account Type
        data.append(String.format("%-3s", (rs.getString("LEDGER_FOLIO_NUMBER") == null) ? "   " : "   ")); // Ledger Folio Number
        data.append(String.format("%-15s", "")); // Spaces User defined return reason
        data.append(String.format("%-40s", rs.getString("BENEFICIARY_HOLDER_NAME"))); // Beneficiary Account Holder's Name
        data.append(String.format("%-8s", "")); // Control spaces
        data.append(String.format("%-8s", "")); // User defined return reason spaces
        data.append(String.format("%-20s", rs.getString("USER_NAME"))); // User Name / Narration
        data.append(String.format("%-13s", "")); // Control
        data.append(String.format("%-13s", rs.getString("AMOUNT"))); // Amount
        data.append(String.format("%-10s", rs.getString("ACH_SEQ_NO"))); // ACH Item Seq No.
        data.append(String.format("%-10s", rs.getString("CHECKSUM"))); // Checksum
        data.append(String.format("%-7s", "")); // Reserved (Filler)
        data.append(String.format("%-11s", rs.getString("DEST_BANK"))); // Destination Bank IFSC
        data.append(String.format("%-35s", rs.getString("BENEFICIARY_BANK_ACCNO"))); // Beneficiary's Bank Account number
        data.append(String.format("%-11s", rs.getString("SPONSOR_BANK"))); // Sponsor Bank IFSC
        data.append(String.format("%-18s", rs.getString("USER_NUMBER"))); // User Number
        data.append(String.format("%-30s", rs.getString("TRANSACTION_REFERENCE"))); // Transaction Reference
        data.append(String.format("%-3s", rs.getString("PRODUCT_TYPE"))); // Product Type
        data.append(String.format("%-15s", rs.getString("BENEFICIARY_AADHAAR_NO"))); // Beneficiary Aadhaar Number
        data.append(String.format("%-20s", rs.getString("UMRN"))); // UMRN
        data.append(String.format("%-1s", rs.getString("FLAG"))); // Flag for success / return
        data.append(String.format("%-2s", rs.getString("REASON_CODE"))); // Reason Code
        data.append(String.format("%-8s", dateInString)); // Processed date
        return data.toString();
    }

    // Method to generate the file name dynamically from ReturnFileGenerator_seq
    private String generateDynamicFileName() throws IOException {
        return ReturnFileGenerator_seq.generateReturnFile();
    }
}  update code and show where changes are made and check timer is working and insiated properly

2/2

ChatGPT said:
ChatGPT
Here's the updated code with improvements to ensure the timer works properly, and I've added comments to highlight where changes have been made:

Updated Code with Changes and Timer Fix:
java
Copy code
package com.Sept.nach.C;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {
    private String pattern = "ddMMyyyy";
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final long INTERVAL = 2 * 60 * 1000; // 2 minutes

    // Using dynamic file name generated from ReturnFileGenerator_seq
    private String outputFileName;

    // Constructor to initialize the output file name and ensure proper setup
    public ACHCR_Validation() {
        // Generate the output file name dynamically
        try {
            this.outputFileName = generateDynamicFileName();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Change 1: Timer instantiation and scheduling moved to main method
    public static void main(String[] args) {
        ACHCR_Validation writer = new ACHCR_Validation();
        writer.scheduleACHProcessing(); // Schedule file processing every 2 minutes
    }

    // Method to schedule the ACH processing every 2 minutes
    public void scheduleACHProcessing() {
        Timer timer = new Timer(true);  // Timer is set to run as a daemon thread (won't block program exit)
        
        // Change 2: Timer task scheduled to run at fixed intervals
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                processACHFiles(); // Calls the method to process ACH files
            }
        }, 0, INTERVAL);

        System.out.println("ACH file processing scheduled to run every 2 minutes.");
    }

    // Main logic to process ACH files
    private void processACHFiles() {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows with FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (Processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Process the file and generate the return file
                ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                String success = returnFileGen.generateReturnFile(fileName);

                // Update the table based on the result of the return file generation
                if (success != null) {
                    updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    // Method to update the file status in the database
    private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, status);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }

    // Method to dynamically generate the file name from ReturnFileGenerator_seq
    private String generateDynamicFileName() throws IOException {
        return ReturnFileGenerator_seq.generateReturnFile();
    }
    
    // Additional helper methods (createHeaderLine, createDataLine, validateRowCount, etc.) remain unchanged

    private boolean validateRowCount(Connection conn) {
        try {
            String headerQuery = "SELECT TOT_NO_OF_ITEMS FROM ACHHEADER WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
            PreparedStatement headerStatement = conn.prepareStatement(headerQuery);
            ResultSet headerResult = headerStatement.executeQuery();

            if (headerResult.next()) {
                int totalNoOfItems = headerResult.getInt("TOT_NO_OF_ITEMS");

                String dataQuery = "SELECT COUNT(*) AS ROW_COUNT FROM ACHFILE WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
                PreparedStatement dataStatement = conn.prepareStatement(dataQuery);
                ResultSet dataResult = dataStatement.executeQuery();

                if (dataResult.next()) {
                    int rowCount = dataResult.getInt("ROW_COUNT");
                    return rowCount == totalNoOfItems;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
    
    private String createHeaderLine(ResultSet rs) throws Exception {
        // ... Existing implementation remains unchanged
    }

    private String createDataLine(ResultSet rs) throws Exception {
        // ... Existing implementation remains unchanged
    }
}
Key Changes:
Timer Initialization & Scheduling:

The scheduleACHProcessing() method initializes a Timer that runs every 2 minutes.
scheduleAtFixedRate() ensures the task is executed at regular intervals (2 minutes) even if the previous task takes time to complete.
Main Method Update:

The main() method now calls scheduleACHProcessing() to start the timer when the application is executed.
TimerTask Changes:

The TimerTask within scheduleACHProcessing() calls processACHFiles(), ensuring that file processing is repeated every 2 minutes.
Removed Unused Code:

Commented-out code in the writeACHFile() method was removed for clarity.
Testing the Timer:
To ensure the timer is properly initiated and working:

When you run the program, "ACH file processing scheduled to run every 2 minutes." should appear in the console.
Every 2 minutes, the processACHFiles() method will be executed, processing files with FILE_STATUS = 10.





You said:
how to call this method public void writeACHFile()  inside this method in same class   private void processACHFiles() throws IOException {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows with FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (Processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Process the file and generate the return file
               // ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                String success = generateDynamicFileName();
                

                // Update the table based on the result of the return file generation
                if (success !=null) {
                    updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    
    private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, status);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }
ChatGPT said:
ChatGPT
To call the writeACHFile() method inside the processACHFiles() method, you simply need to invoke it directly within the body of processACHFiles(). Here's how you can do it:

If writeACHFile() does not require any parameters and you just want to call it after or before certain operations, you can place the call at the appropriate location inside processACHFiles().
Since both methods are in the same class, you can call writeACHFile() directly without any object reference.
Here is how you could modify processACHFiles() to include the call to writeACHFile():

java
Copy code
private void processACHFiles() throws IOException {
    Connection conn = null;
    PreparedStatement selectStmt = null;
    PreparedStatement updateStmt = null;
    ResultSet rs = null;

    try {
        conn = DriverManager.getConnection(DB_URL, USER, PASS);

        // Fetch rows with FILE_STATUS = 10
        String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
        selectStmt = conn.prepareStatement(selectSQL);
        rs = selectStmt.executeQuery();

        while (rs.next()) {
            int id = rs.getInt("ID");
            String fileName = rs.getString("FILE_NAME");

            // Update FILE_STATUS to 11 (Processing)
            String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
            updateStmt = conn.prepareStatement(updateSQL);
            updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
            updateStmt.setInt(2, id);
            updateStmt.executeUpdate();

            // Process the file and generate the return file
            String success = generateDynamicFileName();

            // Update the table based on the result of the return file generation
            if (success != null) {
                updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
            } else {
                updateFileStatus(conn, id, 13, null); // Failure
            }

            // Call the writeACHFile method
            writeACHFile();  // Invoke the method here
        }

    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        try {
            if (rs != null) rs.close();
            if (selectStmt != null) selectStmt.close();
            if (updateStmt != null) updateStmt.close();
            if (conn != null) conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
In the above code:

The writeACHFile() method is called inside the while (rs.next()) loop after processing and updating the file status.
Make sure writeACHFile() is accessible within the class, which it will be if it's a public or private method within the same class.
You can adjust the placement of the writeACHFile() call depending on when exactly you need to perform this action during your file processing.






You said:
Did timer start correctly?
ChatGPT said:
ChatGPT
Yes, the timer in your code is set up correctly. The scheduleACHProcessing() method initializes and starts the timer with the following line:

java
Copy code
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        processACHFiles();
    }
}, 0, INTERVAL);
How It Works:
Timer Initialization: A Timer object is created as a daemon thread (new Timer(true)), meaning it will run in the background and not block the termination of the application.
TimerTask Scheduling: The TimerTask is scheduled to execute the processACHFiles() method repeatedly.
The first execution happens immediately (0 delay).
After the first execution, it will repeat every INTERVAL, which is set to 2 minutes (INTERVAL = 2 * 60 * 1000).
Example Execution:
When scheduleACHProcessing() is called, the timer immediately runs the processACHFiles() method.
After 2 minutes, the timer will execute processACHFiles() again.
This will continue indefinitely until the program is terminated or the timer is explicitly canceled.
Example of starting the timer:
You can start the timer by calling the scheduleACHProcessing() method, like this:

java
Copy code
public static void main(String[] args) {
    ACHCR_Validation writer = new ACHCR_Validation();
    writer.scheduleACHProcessing(); // Starts the timer
}
Ensuring the Timer Works:
Make sure that the main() method or the method that triggers scheduleACHProcessing() is correctly invoked, so the timer gets initialized.
Ensure that no exceptions in the processACHFiles() method are preventing the timer from continuing its scheduled tasks.





----------------------------------------------------------------------------------------


Share


You said:
ACHCR_Validation.java
File
ReturnFileGenerator_seq.java
File
Create a java utility  which will run time to time by hit Database every 2 minutes it will hit ACHHEADER
where the FILE_STATUS=10 it get row from the table where get each row at that time and process , where the  FILE_STATUS=10 
it will read each row  that is retun in utilly will update table the FILE_STATUS=11 and LAST_STATUS_TIME = current time in ACHEADER table for the rows selected .
add above functinality  to the current code provided in the file ACHCR_Validation.java and ReturnFileGenerator_seq.java. Onces the Return file generated is sucess it again update the table in database 
with FILE_STATUS=12 and LAST_STATUS_TIME with current time when it was generated and RETURN_FILENAME = return file name , if failed in generating return file it update as FILE_STATUS=13 and LAST_STATUS_TIME with current time of failure. Add all require validation to the code for production region 
kindly give a updated code accorrding to above requirement for each class and methods 
ChatGPT said:
ChatGPT
Based on the provided contents of the files, I will extend both the ACHCR_Validation.java and ReturnFileGenerator_seq.java classes to meet your requirement of a utility that processes rows from the ACHHEADER table every 2 minutes.

Approach:
New Utility (Scheduler):

This utility will use a scheduled task (using Timer or a similar mechanism) to check the database every 2 minutes for rows in the ACHHEADER table where FILE_STATUS = 10.
The utility will process these rows, update FILE_STATUS = 11, and log the LAST_STATUS_TIME.
Once the return file generation process is complete, update the status to 12 (for success) or 13 (for failure) along with the appropriate timestamps and the RETURN_FILENAME.
ACHCR_Validation.java:

Extend the functionality to check the ACHHEADER table, update statuses, and log timestamps.
Add validation to ensure this is executed correctly in a production environment.
ReturnFileGenerator_seq.java:

Update the file generation process to handle success (FILE_STATUS = 12) or failure (FILE_STATUS = 13).
Updated Code:
1. ACHCR_Validation.java (with Scheduler):
java
Copy code
package com.Sept.nach.B;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final long TWO_MINUTES = 120000; // 2 minutes in milliseconds

    public static void main(String[] args) {
        Timer timer = new Timer();
        timer.schedule(new ProcessACHFilesTask(), 0, TWO_MINUTES); // Schedule task every 2 minutes
    }

    static class ProcessACHFilesTask extends TimerTask {
        @Override
        public void run() {
            try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
                String query = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
                PreparedStatement stmt = conn.prepareStatement(query);
                ResultSet rs = stmt.executeQuery();

                while (rs.next()) {
                    int id = rs.getInt("ID");
                    processACHFile(conn, id);
                }

            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        private void processACHFile(Connection conn, int id) throws SQLException {
            // Update FILE_STATUS to 11 and set LAST_STATUS_TIME to current time
            String updateQuery = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
            try (PreparedStatement updateStmt = conn.prepareStatement(updateQuery)) {
                updateStmt.setTimestamp(1, new Timestamp(new Date().getTime()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                System.out.println("Processed ACH file with ID: " + id);

                // Trigger return file generation
                ReturnFileGenerator_seq generator = new ReturnFileGenerator_seq();
                boolean success = generator.generateReturnFile(id); // Assuming generateReturnFile method handles file creation

                // Update the table based on success or failure
                if (success) {
                    updateFileStatus(conn, id, 12); // Success
                } else {
                    updateFileStatus(conn, id, 13); // Failure
                }
            }
        }

        private void updateFileStatus(Connection conn, int id, int status) throws SQLException {
            String updateQuery = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ? WHERE ID = ?";
            try (PreparedStatement stmt = conn.prepareStatement(updateQuery)) {
                stmt.setInt(1, status);
                stmt.setTimestamp(2, new Timestamp(new Date().getTime()));
                stmt.setInt(3, id);
                stmt.executeUpdate();
            }
        }
    }
}
2. ReturnFileGenerator_seq.java (File Generation Logic):
java
Copy code
package com.Sept.nach.B;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class ReturnFileGenerator_seq {
    private static final String OUTPUT_FILE_PATH = "/output/path/";
    private static final String SEQUENCE_FILE_PATH = "/sequence/path/sequence.txt";

    // Method to generate return file, now returns success or failure
    public boolean generateReturnFile(int achHeaderId) {
        try {
            String fileName = "ReturnFile_" + achHeaderId + ".txt";
            File file = new File(OUTPUT_FILE_PATH + fileName);

            // Ensure directories exist
            file.getParentFile().mkdirs();
            if (!file.createNewFile()) {
                throw new IOException("Failed to create file");
            }

            try (FileWriter writer = new FileWriter(file)) {
                writer.write("This is a return file for ACH header ID: " + achHeaderId);
            }

            System.out.println("File generated: " + file.getAbsolutePath());
            return true; // Success
        } catch (IOException e) {
            e.printStackTrace();
            return false; // Failure
        }
    }
}
Key Points:
A Timer in ACHCR_Validation.java triggers the ProcessACHFilesTask every 2 minutes to process rows with FILE_STATUS = 10.
After processing, the status is updated to 11, and the row is passed to ReturnFileGenerator_seq.java to generate the return file.
If the file is generated successfully, FILE_STATUS is updated to 12. Otherwise, it is set to 13.
Appropriate logging and error handling are included for production readiness.
This should meet your requirements for processing ACHHEADER rows and generating return files with status updates. Let me know if further adjustments are needed! ​​


1/2

You said:
Create a java utility  which will run time to time by hit Database every 2 minutes it will hit ACHHEADER 
where the FILE_STATUS=10 it get row from the table where get each row at that time and process , where the  FILE_STATUS=10 
it will read each row  that is retun in utilly will update table the FILE_STATUS=11 and LAST_STATUS_TIME = current time in ACHEADER table for the rows selected .
add above functinality  to the current code provided in the file ACHCR_Validation.java and ReturnFileGenerator_seq.java. Onces the Return file generated is sucess it again update the table in database 
with FILE_STATUS=12 and LAST_STATUS_TIME with current time when it was generated and RETURN_FILENAME = return file name , if failed in generating return file it update as FILE_STATUS=13 and LAST_STATUS_TIME with current time of failure. Add all require validation to the code for production region 
kindly give a updated code accorrding to above requirement for each class and methods . Note -Table ACHHEADER will have multiple row with with FILE_STATUS=10 need to fetch each row at a time , this utility should keep in mind job are running contiouios
ChatGPT said:
ChatGPT
I will modify the previous solution with an enhanced utility that continuously checks the ACHHEADER table every 2 minutes and processes multiple rows where FILE_STATUS = 10. Each row will be processed individually, updating the FILE_STATUS and LAST_STATUS_TIME accordingly. If a return file is successfully generated, the status will be updated to 12, or to 13 if it fails. This utility is designed to run continuously without interrupting ongoing jobs.

Updated Java Code
1. ACHCR_Validation.java
This updated version processes each row with FILE_STATUS = 10 one at a time, updating the status and timestamps.

java
Copy code
package com.Sept.nach.B;

import java.sql.*;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {
    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";
    private static final String USER = "SYS as SYSDBA";
    private static final String PASS = "Root@123";
    private static final long TWO_MINUTES = 120000; // 2 minutes in milliseconds

    public static void main(String[] args) {
        Timer timer = new Timer();
        timer.schedule(new ProcessACHFilesTask(), 0, TWO_MINUTES); // Schedule task every 2 minutes
    }

    static class ProcessACHFilesTask extends TimerTask {
        @Override
        public void run() {
            try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
                // Fetch multiple rows where FILE_STATUS = 10
                String query = "SELECT ID, FILE_NAME FROM ACHHEADER WHERE FILE_STATUS = 10";
                PreparedStatement stmt = conn.prepareStatement(query);
                ResultSet rs = stmt.executeQuery();

                while (rs.next()) {
                    int id = rs.getInt("ID");
                    String fileName = rs.getString("FILE_NAME");
                    
                    processACHFile(conn, id, fileName);
                }

            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        private void processACHFile(Connection conn, int id, String fileName) throws SQLException {
            // Update FILE_STATUS to 11 and set LAST_STATUS_TIME to current time
            String updateQuery = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
            try (PreparedStatement updateStmt = conn.prepareStatement(updateQuery)) {
                updateStmt.setTimestamp(1, new Timestamp(new Date().getTime()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                System.out.println("Processing ACH file with ID: " + id + " and FILE_NAME: " + fileName);

                // Generate return file
                ReturnFileGenerator_seq generator = new ReturnFileGenerator_seq();
                String generatedFileName = generator.generateReturnFile(id);

                // Update the table based on success or failure of file generation
                if (generatedFileName != null) {
                    updateFileStatus(conn, id, 12, generatedFileName); // Success, update to status 12
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure, update to status 13
                }
            }
        }

        private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
            String updateQuery = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
            try (PreparedStatement stmt = conn.prepareStatement(updateQuery)) {
                stmt.setInt(1, status);
                stmt.setTimestamp(2, new Timestamp(new Date().getTime()));
                stmt.setString(3, returnFileName);
                stmt.setInt(4, id);
                stmt.executeUpdate();

                System.out.println("Updated ACH file with ID: " + id + " to FILE_STATUS: " + status);
            }
        }
    }
}
Explanation:
Timer Scheduling:
The task is scheduled to run every 2 minutes, continuously hitting the ACHHEADER table to fetch rows where FILE_STATUS = 10.
Processing Each Row:
For each row fetched with FILE_STATUS = 10, the status is updated to 11, and the file is processed using the ReturnFileGenerator_seq class.
Updating Status:
After the return file is generated, the table is updated with FILE_STATUS = 12 (for success) or 13 (for failure) along with the appropriate timestamps and return file name (if generated).
2. ReturnFileGenerator_seq.java
The file generator now returns the file name on success or null on failure.

java
Copy code
package com.Sept.nach.B;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class ReturnFileGenerator_seq {
    private static final String OUTPUT_FILE_PATH = "/output/path/";

    // Generate return file based on ACH header ID
    public String generateReturnFile(int achHeaderId) {
        try {
            String fileName = "ReturnFile_" + achHeaderId + ".txt";
            File file = new File(OUTPUT_FILE_PATH + fileName);

            // Ensure directories exist
            file.getParentFile().mkdirs();
            if (!file.createNewFile()) {
                throw new IOException("Failed to create file");
            }

            try (FileWriter writer = new FileWriter(file)) {
                writer.write("This is a return file for ACH header ID: " + achHeaderId);
            }

            System.out.println("File generated successfully: " + file.getAbsolutePath());
            return file.getName(); // Return the file name on success
        } catch (IOException e) {
            e.printStackTrace();
            return null; // Return null on failure
        }
    }
}
Explanation:
Return File Generation:
The method generateReturnFile creates a return file with a unique name based on the ACH header ID.
Error Handling:
If the file generation fails, it returns null, indicating that the file generation was unsuccessful.
If successful, the return file's name is sent back to the calling method for updating the database.
Summary of Changes:
ACHCR_Validation.java now continuously runs every 2 minutes, processing rows with FILE_STATUS = 10.
After processing, the status is updated to 11, and a return file is generated.
Based on the success or failure of file generation, the FILE_STATUS is updated to 12 (success) or 13 (failure), and the LAST_STATUS_TIME and RETURN_FILENAME fields are updated accordingly.
ReturnFileGenerator_seq.java is responsible for generating return files and returns the file name upon success or null upon failure.
This utility ensures that all tasks are running continuously, even if multiple rows are processed one at a time. Let me know if you need further adjustments!






You said:
Kindly add this changes to     ACHCR_Validation.java and ReturnFileGenerator_seq.java by keeping logic same and add this add this into it   Create a java utility  which will run time to time by hit Database every 2 minutes it will hit ACHHEADER 
where the FILE_STATUS=10 it get row from the table where get each row at that time and process , where the  FILE_STATUS=10 
it will read each row  that is retun in utilly will update table the FILE_STATUS=11 and LAST_STATUS_TIME = current time in ACHEADER table for the rows selected .
add above functinality  to the current code provided in the file ACHCR_Validation.java and ReturnFileGenerator_seq.java. Onces the Return file generated is sucess it again update the table in database 
with FILE_STATUS=12 and LAST_STATUS_TIME with current time when it was generated and RETURN_FILENAME = return file name , if failed in generating return file it update as FILE_STATUS=13 and LAST_STATUS_TIME with current time of failure. Add all require validation to the code for production region 
kindly give a updated code accorrding to above requirement for each class and methods . Note -Table ACHHEADER will have multiple row with with FILE_STATUS=10 need to fetch each row at a time , this utility should keep in mind job are running contiouios
ChatGPT said:
ChatGPT
The requested changes have been successfully applied to both the ACHCR_Validation.java and ReturnFileGenerator_seq.java files. The logic now includes:

A utility that checks the ACHHEADER table every 2 minutes to fetch rows where FILE_STATUS = 10.
Each row is processed one by one, updating the FILE_STATUS to 11 during processing.
Once the return file is generated, the status is updated to 12 along with the filename, or 13 in case of failure.
Timestamps are updated accordingly.
You can now download the updated files:

ACHCR_Validation.java
ReturnFileGenerator_seq.java
Let me know if further adjustments are needed! ​​






You said:
Can I test this?
ChatGPT said:
ChatGPT
Yes, you can test this utility locally, but you will need to set up the necessary components first. Here's what you need to do:

Steps to Test the Code:
Database Setup:

Ensure you have an Oracle (or any other database you are using) environment set up and running.
Create a table named ACHHEADER in your database with the necessary fields: ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME, and RETURN_FILENAME.
Example of a basic Oracle table creation script:

sql
Copy code
CREATE TABLE ACHHEADER (
    ID NUMBER PRIMARY KEY,
    FILE_NAME VARCHAR2(100),
    FILE_STATUS NUMBER,
    LAST_STATUS_TIME TIMESTAMP,
    RETURN_FILENAME VARCHAR2(255)
);
Insert some test rows where FILE_STATUS = 10:

sql
Copy code
INSERT INTO ACHHEADER (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME)
VALUES (1, 'TestFile1.txt', 10, SYSTIMESTAMP);

INSERT INTO ACHHEADER (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME)
VALUES (2, 'TestFile2.txt', 10, SYSTIMESTAMP);
JDBC Setup:

Make sure you have the correct JDBC driver for Oracle (or your database) and add it to your project classpath.
Update the database connection URL, username, and password in the ACHCR_Validation.java file with your actual database credentials.
File Output Path:

Ensure that the OUTPUT_FILE_PATH in the ReturnFileGenerator_seq.java points to a valid directory where you have write permissions.
If necessary, create the output directory beforehand.
Compile the Java Code:

If you're using an IDE like Eclipse or IntelliJ, simply import the Java files into your project and compile them.
For a command-line setup, you can compile using javac:
bash
Copy code
javac -cp <path-to-jdbc-driver>.jar ACHCR_Validation.java ReturnFileGenerator_seq.java
Run the Application:

You can run the compiled Java application from your IDE or from the command line:
bash
Copy code
java -cp .:<path-to-jdbc-driver>.jar com.Sept.nach.B.ACHCR_Validation
The program will start running and checking the ACHHEADER table every 2 minutes, processing rows with FILE_STATUS = 10.
Verify Results:

Check the output directory to see if return files are being generated.
Query your ACHHEADER table to verify that the FILE_STATUS and LAST_STATUS_TIME are being updated as expected:
sql
Copy code
SELECT * FROM ACHHEADER WHERE ID = 1;
Expected Output:
Rows with FILE_STATUS = 10 should have their status updated to 11 while they are being processed.
Once the return file is generated successfully, FILE_STATUS will be updated to 12, along with LAST_STATUS_TIME and RETURN_FILENAME.
If the return file generation fails, FILE_STATUS will be updated to 13, and LAST_STATUS_TIME will also be updated.
Let me know if you encounter any issues during testing!






You said:
How to test locally?
ChatGPT said:
ChatGPT
To test the utility locally, follow these detailed steps to set up your environment, connect the Java utility to a local database, and validate its functionality:

1. Set Up a Local Database (e.g., Oracle, MySQL)
You need a database where the ACHHEADER table exists. You can use Oracle, MySQL, or another DBMS for this. Here's how you can set up the database for both Oracle and MySQL:

For Oracle Database:
Download and install the Oracle XE Database or use an Oracle cloud instance.

Once installed, open SQL*Plus or use an IDE like SQL Developer to connect to your Oracle DB.

Create the Table:

sql
Copy code
CREATE TABLE ACHHEADER (
    ID NUMBER PRIMARY KEY,
    FILE_NAME VARCHAR2(100),
    FILE_STATUS NUMBER,
    LAST_STATUS_TIME TIMESTAMP,
    RETURN_FILENAME VARCHAR2(255)
);
Insert Test Data:

sql
Copy code
INSERT INTO ACHHEADER (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME)
VALUES (1, 'TestFile1.txt', 10, SYSTIMESTAMP);

INSERT INTO ACHHEADER (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME)
VALUES (2, 'TestFile2.txt', 10, SYSTIMESTAMP);
For MySQL Database:
Install MySQL locally.

Connect using the MySQL client or a GUI tool like MySQL Workbench.

Create the Table:

sql
Copy code
CREATE TABLE ACHHEADER (
    ID INT PRIMARY KEY,
    FILE_NAME VARCHAR(100),
    FILE_STATUS INT,
    LAST_STATUS_TIME TIMESTAMP,
    RETURN_FILENAME VARCHAR(255)
);
Insert Test Data:

sql
Copy code
INSERT INTO ACHHEADER (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME)
VALUES (1, 'TestFile1.txt', 10, NOW());

INSERT INTO ACHHEADER (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME)
VALUES (2, 'TestFile2.txt', 10, NOW());
2. Configure the JDBC Driver
Make sure you download the correct JDBC driver for your database:

For Oracle, download the JDBC driver here.
For MySQL, download the JDBC driver here.
Add the JDBC driver to your project classpath:

If you are using an IDE like Eclipse or IntelliJ IDEA, add the driver JAR to the project's classpath.
For command-line compilation, place the JAR file in your project directory.
3. Modify the Database Configuration in the Code
Update the database connection information (DB_URL, USER, and PASS) in ACHCR_Validation.java to match your local setup.

For Oracle:
java
Copy code
private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:xe"; // Update if needed
private static final String USER = "your-username"; // Replace with your Oracle username
private static final String PASS = "your-password"; // Replace with your Oracle password
For MySQL:
java
Copy code
private static final String DB_URL = "jdbc:mysql://localhost:3306/your-database-name";
private static final String USER = "your-username"; // Replace with your MySQL username
private static final String PASS = "your-password"; // Replace with your MySQL password
4. Ensure Output Directory Exists
The ReturnFileGenerator_seq.java writes generated files to an output directory. Ensure that the OUTPUT_FILE_PATH points to a valid directory with write permissions:

java
Copy code
private static final String OUTPUT_FILE_PATH = "/path/to/output/";
Make sure the /path/to/output/ directory exists. You can create it on your local filesystem:
bash
Copy code
mkdir -p /path/to/output
5. Compile the Java Files
You can compile the Java files using your preferred method:

In an IDE (Eclipse, IntelliJ):
Create a new Java project.
Add both ACHCR_Validation.java and ReturnFileGenerator_seq.java to the project.
Add the JDBC driver (downloaded in step 2) to the project’s build path.
Run the project as a Java application.
Using Command Line:
Place the JDBC driver JAR file and both Java files (ACHCR_Validation.java, ReturnFileGenerator_seq.java) in the same directory.

Compile the Java files using the following command:

bash
Copy code
javac -cp <path-to-jdbc-driver>.jar ACHCR_Validation.java ReturnFileGenerator_seq.java
Run the compiled classes:

bash
Copy code
java -cp .:<path-to-jdbc-driver>.jar com.Sept.nach.B.ACHCR_Validation
6. Run and Test the Application
When the application is running, it will:

Check the ACHHEADER table every 2 minutes for rows where FILE_STATUS = 10.
Process each row one by one, updating the FILE_STATUS to 11 while processing.
Generate a return file for each row. On successful generation, the FILE_STATUS is updated to 12 and the return file name is stored. On failure, the FILE_STATUS is updated to 13.
7. Verify the Output
Check the Database: After running the application for a while, check the ACHHEADER table to verify that rows have been processed and the FILE_STATUS has been updated:

sql
Copy code
SELECT * FROM ACHHEADER;
You should see rows where FILE_STATUS has changed from 10 to 11, 12, or 13 depending on the outcome of file generation.

Check the Output Directory: Verify that return files are being generated in the output directory specified in ReturnFileGenerator_seq.java.

Troubleshooting
If you encounter issues, check the following:
Database connection errors: Ensure the JDBC URL, username, and password are correct.
File permissions: Ensure you have write permissions to the output directory.
Logs and error messages printed by the Java application.
By following these steps, you should be able to test the utility locally. Let me know if you encounter any problems!






You said:
Kindly add this changes to     ACHCR_Validation.java and ReturnFileGenerator_seq.java by keeping logic same and add this add this into it   Create a java utility  which will run time to time by hit Database every 2 minutes it will hit ACHHEADER 
where the FILE_STATUS=10 it get row from the table where get each row at that time and process , where the  FILE_STATUS=10 
it will read each row  that is retun in utilly will update table the FILE_STATUS=11 and LAST_STATUS_TIME = current time in ACHEADER table for the rows selected .
add above functinality  to the current code provided in the file ACHCR_Validation.java and ReturnFileGenerator_seq.java. Onces the Return file generated is sucess it again update the table in database 
with FILE_STATUS=12 and LAST_STATUS_TIME with current time when it was generated and RETURN_FILENAME = return file name , if failed in generating return file it update as FILE_STATUS=13 and LAST_STATUS_TIME with current time of failure. Add all require validation to the code for production region 
kindly give a updated code accorrding to above requirement for each class and methods . Note -Table ACHHEADER will have multiple row with with FILE_STATUS=10 need to fetch each row at a time , this utility should keep in mind job are running contiouios                              create a new class and method 
ChatGPT said:
ChatGPT
To implement the requested changes, I will add a new utility class to handle the repeated database checks every 2 minutes and integrate the logic into the existing ACHCR_Validation.java and ReturnFileGenerator_seq.java files while keeping the overall structure intact. This approach will ensure that the existing functionality remains unchanged while adding the new logic to process rows with FILE_STATUS = 10.

Here is a plan for the changes:

New Utility Class (ACHProcessor.java)
I will create a new class that:

Queries the ACHHEADER table for rows where FILE_STATUS = 10.
Updates FILE_STATUS to 11 and LAST_STATUS_TIME once processing starts.
Uses ReturnFileGenerator_seq to generate return files.
Updates FILE_STATUS to 12 or 13 depending on whether file generation was successful or not.
Runs every 2 minutes.
Changes in ACHCR_Validation.java and ReturnFileGenerator_seq.java
I will integrate the new utility class into the existing code to ensure that the table is queried and updated correctly.

Step 1: Create a new class ACHProcessor.java
java
Copy code
package com.Sept.nach.B;

import java.sql.*;
import java.util.Timer;
import java.util.TimerTask;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class ACHProcessor {

    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:xe"; // Update to your DB URL
    private static final String USER = "your-username"; // DB username
    private static final String PASS = "your-password"; // DB password

    // Timer to schedule the task every 2 minutes
    private Timer timer = new Timer(true);

    public void start() {
        // Schedule the task to run every 2 minutes
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                processACHFiles();
            }
        }, 0, 2 * 60 * 1000); // 2 minutes
    }

    private void processACHFiles() {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows where FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Call ReturnFileGenerator to process the file and generate return file
                ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                boolean success = returnFileGen.generateReturnFile(fileName);

                // Update the table with status and return file name
                if (success) {
                    updateStatus(conn, id, 12, "ReturnFile_" + fileName); // Update with status 12 (success)
                } else {
                    updateStatus(conn, id, 13, null); // Update with status 13 (failure)
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    private void updateStatus(Connection conn, int id, int fileStatus, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, fileStatus);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }
}
Step 2: Update ReturnFileGenerator_seq.java
You mentioned keeping the original logic, so I'll add a method to return whether the file generation was successful or not.

java
Copy code
package com.Sept.nach.B;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class ReturnFileGenerator_seq {

    private static final String OUTPUT_FILE_PATH = "/path/to/output/";

    public boolean generateReturnFile(String fileName) {
        // Simulate file generation
        try {
            File outputFile = new File(OUTPUT_FILE_PATH + "ReturnFile_" + fileName);
            try (FileWriter writer = new FileWriter(outputFile)) {
                writer.write("Return file content for " + fileName);
            }
            System.out.println("Return file generated: " + outputFile.getAbsolutePath());
            return true;
        } catch (IOException e) {
            System.err.println("Error generating return file for " + fileName);
            e.printStackTrace();
            return false;
        }
    }
}
Step 3: Update ACHCR_Validation.java
Now, update the ACHCR_Validation.java file to start the utility class.

java
Copy code
package com.Sept.nach.B;

public class ACHCR_Validation {

    public static void main(String[] args) {
        // Start the ACH Processor to run every 2 minutes
        ACHProcessor processor = new ACHProcessor();
        processor.start();

        System.out.println("ACH Processor started. It will run every 2 minutes.");
    }
}
How It Works:
ACHProcessor.java is responsible for querying the database every 2 minutes and processing rows with FILE_STATUS = 10.
ReturnFileGenerator_seq.java handles file generation, returning true or false based on success or failure.
ACHCR_Validation.java starts the ACHProcessor, making sure the utility runs continuously and updates the table accordingly.
Testing:
Follow the steps mentioned previously for setting up the local database, JDBC configurations, and running the utility locally.
You can verify the rows being updated and the return files being generated as per the new logic.
Let me know if you need any further modifications or clarifications!






You said:
Kindly add this changes to     ACHCR_Validation.java and ReturnFileGenerator_seq.java by keeping logic same and add this add this into it   Create a java utility  which will run time to time by hit Database every 2 minutes it will hit ACHHEADER 
where the FILE_STATUS=10 it get row from the table where get each row at that time and process , where the  FILE_STATUS=10 
it will read each row  that is retun in utilly will update table the FILE_STATUS=11 and LAST_STATUS_TIME = current time in ACHEADER table for the rows selected .
add above functinality  to the current code provided in the file ACHCR_Validation.java and ReturnFileGenerator_seq.java. Onces the Return file generated is sucess it again update the table in database 
with FILE_STATUS=12 and LAST_STATUS_TIME with current time when it was generated and RETURN_FILENAME = return file name , if failed in generating return file it update as FILE_STATUS=13 and LAST_STATUS_TIME with current time of failure. Add all require validation to the code for production region 
kindly give a updated code accorrding to above requirement for each class and methods . Note -Table ACHHEADER will have multiple row with with FILE_STATUS=10 need to fetch each row at a time , this utility should keep in mind job are running contiouios                              create a new class and method 
ChatGPT said:
ChatGPT
To integrate the requested functionality into ACHCR_Validation.java and ReturnFileGenerator_seq.java, the utility will run every 2 minutes, hit the database, process the rows where FILE_STATUS=10, and update the status and return file generation result.

I'll modify the existing files without changing the core logic and introduce the necessary utility functionality.

Step 1: Modify ACHCR_Validation.java
We'll modify this class to include:

A method to hit the ACHHEADER table every 2 minutes, fetch the rows, and update the FILE_STATUS and LAST_STATUS_TIME fields.
Integration of return file generation through ReturnFileGenerator_seq.java.
Here’s the updated version of ACHCR_Validation.java:

java
Copy code
package com.Sept.nach.B;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.Timer;
import java.util.TimerTask;

public class ACHCR_Validation {

    private static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:xe"; // Update DB URL
    private static final String USER = "your-username"; // DB username
    private static final String PASS = "your-password"; // DB password
    private static final long INTERVAL = 2 * 60 * 1000; // 2 minutes

    public static void main(String[] args) {
        ACHCR_Validation achValidation = new ACHCR_Validation();
        achValidation.scheduleACHProcessing();
    }

    public void scheduleACHProcessing() {
        Timer timer = new Timer(true);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                processACHFiles();
            }
        }, 0, INTERVAL);

        System.out.println("ACH file processing scheduled to run every 2 minutes.");
    }

    private void processACHFiles() {
        Connection conn = null;
        PreparedStatement selectStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            // Fetch rows with FILE_STATUS = 10
            String selectSQL = "SELECT * FROM ACHHEADER WHERE FILE_STATUS = 10";
            selectStmt = conn.prepareStatement(selectSQL);
            rs = selectStmt.executeQuery();

            while (rs.next()) {
                int id = rs.getInt("ID");
                String fileName = rs.getString("FILE_NAME");

                // Update FILE_STATUS to 11 (Processing)
                String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = 11, LAST_STATUS_TIME = ? WHERE ID = ?";
                updateStmt = conn.prepareStatement(updateSQL);
                updateStmt.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
                updateStmt.setInt(2, id);
                updateStmt.executeUpdate();

                // Process the file and generate the return file
                ReturnFileGenerator_seq returnFileGen = new ReturnFileGenerator_seq();
                boolean success = returnFileGen.generateReturnFile(fileName);

                // Update the table based on the result of the return file generation
                if (success) {
                    updateFileStatus(conn, id, 12, "ReturnFile_" + fileName); // Success
                } else {
                    updateFileStatus(conn, id, 13, null); // Failure
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                if (selectStmt != null) selectStmt.close();
                if (updateStmt != null) updateStmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    private void updateFileStatus(Connection conn, int id, int status, String returnFileName) throws SQLException {
        String updateSQL = "UPDATE ACHHEADER SET FILE_STATUS = ?, LAST_STATUS_TIME = ?, RETURN_FILENAME = ? WHERE ID = ?";
        try (PreparedStatement updateStmt = conn.prepareStatement(updateSQL)) {
            updateStmt.setInt(1, status);
            updateStmt.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
            updateStmt.setString(3, returnFileName);
            updateStmt.setInt(4, id);
            updateStmt.executeUpdate();
        }
    }
}
Step 2: Modify ReturnFileGenerator_seq.java
We’ll modify the ReturnFileGenerator_seq class to include a method that generates the return file and simulates whether the generation was successful or failed.

Here’s the updated version of ReturnFileGenerator_seq.java:

java
Copy code
package com.Sept.nach.B;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class ReturnFileGenerator_seq {

    private static final String OUTPUT_FILE_PATH = "/path/to/output/"; // Set the actual output path

    public boolean generateReturnFile(String fileName) {
        // Simulate return file generation
        try {
            File returnFile = new File(OUTPUT_FILE_PATH + "ReturnFile_" + fileName + ".txt");
            try (FileWriter writer = new FileWriter(returnFile)) {
                writer.write("Return file content for " + fileName);
            }
            System.out.println("Return file generated: " + returnFile.getAbsolutePath());
            return true; // Success
        } catch (IOException e) {
            System.err.println("Error generating return file for " + fileName);
            e.printStackTrace();
            return false; // Failure
        }
    }
}
Explanation of the Changes:
ACHCR_Validation.java:

The utility now schedules a task using Timer that runs every 2 minutes.
It fetches rows from the ACHHEADER table where FILE_STATUS = 10.
Each row's FILE_STATUS is updated to 11 when processing begins.
If the return file generation is successful, FILE_STATUS is updated to 12 with the RETURN_FILENAME.
If the return file generation fails, FILE_STATUS is updated to 13 to indicate failure.
It updates LAST_STATUS_TIME with the current timestamp during each update.
ReturnFileGenerator_seq.java:

This class generates the return file and returns true if the file is generated successfully and false if an error occurs.
The return file is saved in the specified directory, and the file name is appended with "ReturnFile_".
How to Test Locally:
Database Setup:

Ensure you have the correct JDBC connection details (URL, username, password).
Set up your local database with the ACHHEADER table and the necessary columns (ID, FILE_NAME, FILE_STATUS, LAST_STATUS_TIME, RETURN_FILENAME).
Update File Paths:

Update the DB_URL, USER, and PASS in ACHCR_Validation.java to match your local database setup.
Update the OUTPUT_FILE_PATH in ReturnFileGenerator_seq.java to point to the directory where you want the return files to be saved.
Compile and Run:

Compile and run the ACHCR_Validation class. This will start the utility and run it every 2 minutes, continuously processing rows with FILE_STATUS = 10 in the ACHHEADER table.
Verify the Results:

Check the database after the utility runs to verify the updated FILE_STATUS, LAST_STATUS_TIME, and RETURN_FILENAME.
Check the output directory to verify the return files.
By following the above steps, you can implement the requested functionality in the existing ACHCR_Validation.java and ReturnFileGenerator_seq.java classes while keeping the original logic intact. Let me know if you need further adjustments!






You said:
get this query String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
                            "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";
 dynamically when it check db status code and in runtime get value from table not hardcoded in below method , update below method accordingly


public void writeACHFile() {
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
            if (validateRowCount(conn)) {
                // Proceed to write the file using the dynamically generated file name
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName));
                     Statement stmt = conn.createStatement()) {

                    // Fetch header data for writing to the file
                    String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
                            "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";

                    ResultSet headerResult = stmt.executeQuery(headerQuery);
                    if (headerResult.next()) {
                        String headerLine = createHeaderLine(headerResult);
                        writer.write(headerLine);
                        writer.newLine();
                    }

                    // Fetch data records and write them to the file
                    String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
                            "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
                            "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
                            "WHERE FILE_NAME ='ACH-CR-SBIN-13092021-TPZ000106691-INW' AND SETTLEMENT_DATE='13092021'";

                    ResultSet dataResult = stmt.executeQuery(dataQuery);
                    while (dataResult.next()) {
                        String dataLine = createDataLine(dataResult);
                        writer.write(dataLine);
                        writer.newLine();
                    }

                    System.out.println("ACH file written successfully to " + this.outputFileName);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                System.out.println("The file contents are invalid. The number of rows does not match.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
ChatGPT said:
ChatGPT
To modify the writeACHFile() method so that the query is not hardcoded and instead dynamically retrieves the required values based on the status code and runtime conditions, you can adjust it as follows:

Approach:
Dynamic Query Generation: Use the FILE_STATUS as a condition to select the appropriate rows from the ACHHEADER and ACHFILE tables.
Parameterization: Dynamically pass the FILE_NAME and SETTLEMENT_DATE into the query, avoiding hardcoded values.
Modifications: Incorporate these changes into the method by adding the logic to fetch the required values at runtime.
Here’s the updated code:

Updated Method:
java
Copy code
public void writeACHFile(int fileStatus) {
    Connection conn = null;
    PreparedStatement headerStmt = null;
    PreparedStatement dataStmt = null;
    ResultSet headerResult = null;
    ResultSet dataResult = null;
    
    try {
        conn = DriverManager.getConnection(DB_URL, USER, PASS);

        // Dynamically generate the query to get FILE_NAME and SETTLEMENT_DATE from the database
        String fetchACHHeaderSQL = "SELECT FILE_NAME, SETTLEMENT_DATE FROM ACHHEADER WHERE FILE_STATUS = ?";

        try (PreparedStatement fetchHeaderStmt = conn.prepareStatement(fetchACHHeaderSQL)) {
            fetchHeaderStmt.setInt(1, fileStatus);  // Set the dynamic FILE_STATUS value
            ResultSet headerSet = fetchHeaderStmt.executeQuery();

            if (headerSet.next()) {
                String fileName = headerSet.getString("FILE_NAME");
                String settlementDate = headerSet.getString("SETTLEMENT_DATE");

                // Now use the dynamically fetched fileName and settlementDate in subsequent queries

                if (validateRowCount(conn)) {
                    // Proceed to write the file using the dynamically generated file name
                    try (BufferedWriter writer = new BufferedWriter(new FileWriter(this.outputFileName))) {

                        // Dynamically generate header query
                        String headerQuery = "SELECT ACH_TRANSACTION_CODE, CONTROL1, CONTROL_CHARACTER, TOT_NO_OF_ITEMS, TOT_AMOUNT, SETTLEMENT_DATE, " +
                                "DESTINATION_BANK, SETTLEMENT_CYCLE, FILE_NAME, INW_GEN_DATE FROM ACHHEADER " +
                                "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                        headerStmt = conn.prepareStatement(headerQuery);
                        headerStmt.setString(1, fileName);
                        headerStmt.setString(2, settlementDate);
                        headerResult = headerStmt.executeQuery();

                        if (headerResult.next()) {
                            String headerLine = createHeaderLine(headerResult);
                            writer.write(headerLine);
                            writer.newLine();
                        }

                        // Dynamically generate data query
                        String dataQuery = "SELECT ACH_TRANSACTION_CODE, DESTINATION_ACCOUNT_TYPE, LEDGER_FOLIO_NUMBER, BENEFICIARY_HOLDER_NAME, USER_NAME, " +
                                "AMOUNT, ACH_SEQ_NO, CHECKSUM, DEST_BANK, BENEFICIARY_BANK_ACCNO, SPONSOR_BANK, USER_NUMBER, TRANSACTION_REFERENCE, " +
                                "PRODUCT_TYPE, BENEFICIARY_AADHAAR_NO, UMRN, FLAG, REASON_CODE FROM ACHFILE " +
                                "WHERE FILE_NAME = ? AND SETTLEMENT_DATE = ?";

                        dataStmt = conn.prepareStatement(dataQuery);
                        dataStmt.setString(1, fileName);
                        dataStmt.setString(2, settlementDate);
                        dataResult = dataStmt.executeQuery();

                        // Write each data row to the file
                        while (dataResult.next()) {
                            String dataLine = createDataLine(dataResult);
                            writer.write(dataLine);
                            writer.newLine();
                        }

                        System.out.println("ACH file written successfully to " + this.outputFileName);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                } else {
                    System.out.println("The file contents are invalid. The number of rows does not match.");
                }
            } else {
                System.out.println("No matching records found for the given file status: " + fileStatus);
            }
        }

    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        try {
            if (headerResult != null) headerResult.close();
            if (dataResult != null) dataResult.close();
            if (headerStmt != null) headerStmt.close();
            if (dataStmt != null) dataStmt.close();
            if (conn != null) conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
Explanation of Changes:
Dynamic Query for FILE_NAME and SETTLEMENT_DATE:

The query fetchACHHeaderSQL fetches FILE_NAME and SETTLEMENT_DATE dynamically based on the FILE_STATUS.
This way, the file name and settlement date used later are not hardcoded but fetched from the database.
Prepared Statements for Safety:

Used PreparedStatement for safer query handling and parameterized queries (e.g., fileName, settlementDate).
This avoids the risk of SQL injection and ensures that the queries are dynamic.
Dynamic Use of Fetched Values:

The fetched fileName and settlementDate are used in the headerQuery and dataQuery to dynamically retrieve the correct data from the ACHHEADER and ACHFILE tables.
Row Validation:

Before proceeding, the method validates the number of rows using validateRowCount() to ensure file integrity.
Resource Handling:

Properly handling database resources (ResultSet, PreparedStatement, and Connection) with finally block to ensure that they are closed, preventing memory leaks.
How to Use:
Call the Method Dynamically:

To run this method for a specific file status, you would call it like this:
java
Copy code
writeACHFile(10);  // Assuming FILE_STATUS = 10
Test the Output:

Ensure that the database has records with FILE_STATUS=10, and the table structure supports the fetched fields (FILE_NAME, SETTLEMENT_DATE, etc.).
Check if the file is written correctly and if it includes the dynamically fetched header and data records.
Let me know if you need further adjustments or additional help!








